---
title: "Inherent soil quality experiment"
author:
  - name: Serge Wiltshire
    
abstract: Exploring the impact of a distribution of a persistent inherent soil quality factor.

keywords:
  - agriculture,
  - ecosystem services,
  - tipping points,
  - diversification practices,
  - decision-making
bibliography: 
date: "`r Sys.Date()`"
output: rticles::elsevier_article
layout: 3p # review # review = doublespace, 3p = singlespace, 5p = two-column
header-includes: 
  - \journal{TBD}
  - \usepackage{float}
  - \linenumbers

---

```{r setup, include = FALSE}
rm(list = ls(all.names = TRUE)) # clean environment

# load external scripts
source("../R/load-libraries.R")
source("../R/continuous-model.R")
source("../R/sim-plot-fxns.R")

knitr::opts_chunk$set(echo = TRUE,
                      cache = FALSE,
                      message = TRUE,
                      warning = TRUE,
                      fig.align = "center",
                      dev = "cairo_pdf")

pal <- solarized_pal()(7) # global color pallette
set.seed(4) # random seed
```
  

```{r model_params}

actions <- seq(0, 1, length = 100)
states <- seq(0, 1.5, length = 100)
soil_quals <- seq(0, 1, length = 10)
sq_max_pmod <- .5

params <- list(
  benefit = 1.56, 
  cost = 1, 
  sigma = 0.1, 
  r = 0.1, 
  discount = 0.97, 
  Tmax = 20)

```


```{r global_sim_params}
reps <- 500

init_s <- truncnorm::rtruncnorm(reps, 0, 1, 0.5, 0.2) %>% 
  map_int(function(x) which.min(abs(x - states)))

init_soil_q <- truncnorm::rtruncnorm(reps, 0, 1, 0.5, 0.2) %>% 
  map_int(function(x) which.min(abs(x - soil_quals)))

```


```{r solve_model_for_each_soil_q}

sq_mults <- seq(1-sq_max_pmod, 1+sq_max_pmod, length = length(soil_quals))

solns <- tibble(soil_quals)
for(row in 1:length(soil_quals)) {
  solns$sq_mult[[row]] <- sq_mults[row]
  transition_fn <- function(s, a, params) (s + params$r * (a - s)) * sq_mults[row]
  utility_fn <- function(s, a, params) params$benefit * s - params$cost * a
  solns$model[[row]] <- continuous_model(states, actions, params, transition_fn, utility_fn)
  
}

# model <- continuous_model(states, actions, params, transition_fn, utility_fn)

# solve the MDP
# solns <- MDPtoolbox::mdp_value_iteration(model$P, model$U, params$discount)
# soln_df <- tibble(state = states,# action = actions[soln$policy])
```


```{r sim}
sim <- function(soln, 
                Tmax = params$Tmax,
                x0 = init_s){
  map_dfr(1:length(x0), 
          function(i) sim_mdp(model$P, model$U, soln$policy, params$discount, x0 = x0[i], Tmax = Tmax), 
          .id = "reps")
}
sims_baseline <- sim(base_soln)

```


```{r res_bimodal, fig.width = 6, fig.asp = .5}

ggarrange(
  sim_plot_ts(sims_baseline, title = ggtitle("A. ES state over time"), rmarmod = -5), 
  sim_plot_dens(sims_baseline, title = ggtitle("B. Init. and final state"), tpos = "panel", lab_lo_peak = TRUE, lab_hi_peak = TRUE, lmarmod = -5), 
  widths = c(2.75, 2), nrow = 1, ncol = 2
)

```


```{r res_strategy, fig.width = 3, fig.asp = 1}

state99th <- sims_baseline %>% 
            mutate(state = states[state]) %>% 
            pull(state) %>% 
            quantile(.99) %>% 
            unname()
tpt <- 0
for(si in 1:length(states)-1) {
  if(base_soln_df$action[si] < .1 && base_soln_df$action[si+1] > .9) {
    tpt <- base_soln_df$state[si] + ((base_soln_df$state[2] - base_soln_df$state[1]) / 2)
  }
}

soln_plot(base_soln_df %>% filter(state <= state99th), tpt = tpt)

```
