---
title: "DFS-MDP experiment and figure generation"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, message=FALSE, echo=FALSE}
# knitr::opts_chunk$set(echo = FALSE, 
#                       cache = TRUE,
#                       message = FALSE,
#                       warning = FALSE,
#                       fig.width=7, 
#                       fig.height=3.5, 
#                       fig.align = "center")
library(tidyverse)
library(MDPtoolbox)
library(mdplearning)
source("../R/continuous-model.R")
# set.seed(123456)
set.seed(4)
```


```{r include = FALSE}
library(hrbrthemes)
library(ggplot2)
library(Cairo)
library(extrafont)
extrafont::loadfonts()
ggplot2::theme_set(hrbrthemes::theme_ipsum_rc())

library(ggthemes)
library(ggpubr)
# library(patchwork) # devtools::install_github("thomasp85/patchwork")
# library(ggtext) # devtools::install_github("clauswilke/ggtext")
pal <- solarized_pal()(7)
scale_colour_discrete <- function(...) scale_colour_solarized()
scale_fill_discrete <- function(...) scale_fill_solarized()

## hrbrthemes needs cairo_pdf device
knitr::opts_chunk$set(dev = "cairo_pdf")

```


```{r model_def, results='hide'}
actions <- seq(0, 1, length = 100)
# Allow max(state) > max(actions) to avoid creating a hard boundary on ecosystem state
states <- seq(0, 1.5, length = 100)
params <- list(benefit = 1.57, cost = 1, sigma = 0.1, r = .1)
discount <- 0.97
transition_fn <- function(s, a, params) s + params$r * (a - s)
utility_fn <- function(s,a, params) params$benefit * s - params$cost * a
model <- continuous_model(states, actions, params, transition_fn, utility_fn)
```

```{r model_run, results = "hide"}
soln <- MDPtoolbox::mdp_value_iteration(model$P, model$U, discount)
soln_df <- tibble(state = states,
                  action = actions[soln$policy])
#write_csv(soln_df, "../data/soln_df.csv.gz")
```

## Policy plot

```{r fig_policyfn, fig.cap= "The emergent decision rule"}
soln_df %>%
   ggplot(aes(state,action)) + 
   geom_point(size = 1) +
   geom_vline(xintercept = .477, linetype="dashed", color = "red", size=.7) +
   annotate('label', x = .55, y = .35, label = sprintf('x = %.2f', .477), hjust = 0, vjust = .5, 
                       family = "Roboto Condensed", size = 3.25, label.padding = unit(.15, "lines"), label.size = 0, alpha = .8) +
   annotate("segment", x = .55, xend = .49, y = .35, yend = .35, size=.5, arrow=arrow(length = unit(0.22, "cm"))) +
   labs(x="ES state", y="Optimal action") +
   scale_x_continuous(limits = c(0,1.5), expand = c(.01,.01)) +
   scale_y_continuous(limits = c(0,1), expand = c(.01,.01)) +
   theme(axis.text.x=element_text(size=10),
         axis.text.y=element_text(size=10),
         axis.title.x=element_text(size=10),
         axis.title.y=element_text(size=10),
         panel.grid.minor = element_blank(),
         plot.margin=grid::unit(c(5,5,5,5), "mm"))

ggsave("figs/fig_policy.pdf", device = cairo_pdf, height = 2.5, width = 5)
```



```{r sim_plot_fxn}

sim_plot <- function(sims, panelA_title = ggtitle(NULL), panelB_title = ggtitle(NULL), lab_lo_peak = FALSE, lab_hi_peak = FALSE, dnmarmod = 0, upmarmod = 0){

   df <- sims %>% 
    select(-obs,-value) %>% # tidy
    mutate(state = states[state], action = actions[action]) # rescale
   Tmax <- max(sims$time)

   # plot
   panelA <- df %>% 
     ggplot(aes(time, state, group = reps, col = time)) + 
     geom_path(alpha = 0.1, show.legend = FALSE) + 
      panelA_title +
      labs(x="Time", y="ES state") +
      scale_x_continuous(breaks = seq(1, Tmax, by=2), expand = c(.01,.01)) +
      scale_y_continuous(limits = c(0,1.5), expand = c(.01,.01)) +
      theme(axis.text.x=element_text(size=10),
            axis.text.y=element_text(size=10),
            axis.title.x=element_text(size=10),
            axis.title.y=element_text(size=10),
            plot.title = element_text(size = 10, face = "bold"),
            panel.grid.minor = element_blank(),
            plot.margin=grid::unit(c(5+upmarmod,2,5+dnmarmod,5), "mm"))
   
   panelB <- df %>% filter(time %in% c(1, Tmax))  %>%
      ggplot() + geom_density(aes(state, group = time, fill = time), alpha=0.8) +
      scale_fill_continuous(breaks=c(1, Tmax)) +
      coord_flip() +
      panelB_title +
      labs(x="", y="Density", fill="Time") +
      scale_x_continuous(limits = c(0,1.5), expand = c(.01,.01)) +
      theme(axis.text.x=element_text(size=10),
            axis.text.y=element_blank(),
            axis.title.x=element_text(size=10),
            axis.title.y=element_text(size=10),
            legend.text = element_text(size=10),
            legend.title = element_text(size=10),
            plot.title = element_text(size = 10, face = "bold"),
            panel.grid.minor = element_blank(),
            plot.margin=grid::unit(c(5+upmarmod,5,5+dnmarmod,2), "mm"))
   
   if(lab_lo_peak) {
      ymax <- ggplot_build(panelB)$layout$panel_scales_y[[1]]$range$range[2]
      
      peak_lo <- ggplot_build(panelB)$data[[1]] %>%
         filter(group == 2, x < .4) %>%
         arrange(desc(y)) %>%
         select(x,y) %>%
         filter(row_number()==1)
      
      # dotted line
      panelB <- panelB +
         annotate('segment', x = peak_lo$x, xend = peak_lo$x, y = peak_lo$y - .1 * ymax, yend = peak_lo$y + .1 * ymax, linetype="dotted")
      
      # text annotation (decide whether to place left or right of line)
      if(peak_lo$y > .7 * ymax) {
         panelB <- panelB +
            annotate('label', x = peak_lo$x, y = peak_lo$y - .26 * ymax, label = sprintf('%.2f', peak_lo$x), hjust = .5, vjust = .5, 
                       family = "Roboto Condensed", size = 3, label.padding = unit(.15, "lines"), label.size = 0, alpha = .8) 
      } else {
         panelB <- panelB +
            annotate('label', x = peak_lo$x, y = peak_lo$y + .2 * ymax, label = sprintf('%.2f', peak_lo$x), hjust = .5, vjust = .5, 
                       family = "Roboto Condensed", size = 3, label.padding = unit(.15, "lines"), label.size = 0, alpha = .8) 
      }
   }
   
   if(lab_hi_peak){
      ymax <- ggplot_build(panelB)$layout$panel_scales_y[[1]]$range$range[2]
      
      peak_hi <- ggplot_build(panelB)$data[[1]] %>%
         filter(group == 2, x > .6) %>%
         arrange(desc(y)) %>%
         select(x,y) %>%
         filter(row_number()==1)
      
      # dotted line
      panelB <- panelB +
         annotate('segment', x = peak_hi$x, xend = peak_hi$x, y = peak_hi$y - .1 * ymax, yend = peak_hi$y + .1 * ymax, linetype="dotted")
      
      # text annotation (decide whether to place left or right of line)
      if(peak_hi$y > .7 * ymax) {
         panelB <- panelB +
            annotate('label', x = peak_hi$x, y = peak_hi$y - .26 * ymax, label = sprintf('%.2f', peak_hi$x), hjust = .5, vjust = .5, 
                       family = "Roboto Condensed", size = 3, label.padding = unit(.15, "lines"), label.size = 0, alpha = .8) 
      } else {
         panelB <- panelB +
            annotate('label', x = peak_hi$x, y = peak_hi$y + .2 * ymax, label = sprintf('%.2f', peak_hi$x), hjust = .5, vjust = .5, 
                       family = "Roboto Condensed", size = 3, label.padding = unit(.15, "lines"), label.size = 0, alpha = .8) 
      }
   }

   ggarrange(
     panelA, panelB, widths = c(3, 2), align = "v", nrow = 1, ncol = 2
   )
   
}
```

## Prop decreasing or increasing ES over the run
```{r}
p_up_dn <- function(sims){
i_state <- sims %>%
   filter(time == 1) %>%
   select(state) %>%
   mutate(state = states[state])

f_state <- sims %>%
   filter(time == 10) %>%
   select(state) %>%
   mutate(state = states[state])

state <- data.frame(i = i_state$state, f = f_state$state)

state$up <- state$i < .5 & state$f > .5
state$dn <- state$i > .5 & state$f < .5

# c(mean(state$up), mean(state$dn))
print(sprintf('prop high final = %.2f, prop low final = %.2f', mean(state$f > .5), mean(state$f < .5)))
print(sprintf('prop increasing = %.2f, prop decreasing = %.2f', mean(state$up), mean(state$dn)))
}
```

## Base case simulation

```{r results="hide"}
reps <- 500
init <- truncnorm::rtruncnorm(reps, 0, 1, 0.5, 0.2) %>% 
                  map_int(function(x) which.min(abs(x - states)))

sim <- function(soln, 
                Tmax = 10,
                x0 =  init){
  map_dfr(1:length(x0), 
          function(i)
                   mdp_planning(model$P, model$U, discount, 
                   policy = soln$policy,
                   x0 = x0[i], Tmax = Tmax), .id = "reps")
}

sims <- sim(soln)
#write_csv(sims, "../data/sims.csv.gz")
```

```{r fig_bimodal}

sim_plot(sims, lab_lo_peak = TRUE, lab_hi_peak = TRUE)
ggsave("figs/fig_bimodal.pdf", device = cairo_pdf, height = 3, width = 7)

p_up_dn(sims)

```


## Short tenure simulation

```{r results="hide"}
tenure_2 <- MDPtoolbox::mdp_finite_horizon(model$P, model$U, discount, N = 2)
sims_short_tenure <- sim(tenure_2)
#write_csv(sims_short_tenure, "../data/sims_short_tenure.csv.gz")
```

```{r fig_tenure}
sim_plot(sims_short_tenure, lab_lo_peak = TRUE) 
ggsave("figs/fig_short_tenure.pdf", device = cairo_pdf, height = 3, width = 7)

p_up_dn(sims_short_tenure)
```


## Subsidies simulation

```{r results="hide"}
params_subsidy_burst <- list(benefit = 1.57, cost = 0, sigma = 0.1, r = .1)
params_subsidy_sustained <- list(benefit = 1.57, cost = .8, sigma = 0.1, r = .1)

## Note that farmers do not solve the finite-time horizon problem for the short period of the subsidy,
## because they are not "cashing out" (moving off the land) after the subsidy expires.
## This is still not the optimal solution, but is a reasonable approximation.
modelA <- continuous_model(states, actions, params_subsidy_burst, transition_fn, utility_fn)
solnA <- MDPtoolbox::mdp_value_iteration(modelA$P, modelA$U, discount)
  
## Do 2 years with large subsidy (no cost to adoption)
start <- sim(solnA, Tmax = 3, x0 = init)
x1 <- start %>% filter(time == 3) %>% pull(state)
## Go another 18 years with decision rule under no subsidy
rest <- sim(soln, Tmax = 18, x0 = x1) %>% filter(time!=1) %>% mutate(time = time+2)
simA <- bind_rows(start, rest)

## Do 10 years with minor subsidy (subsidize 10% of unit cost over first 10 years)
modelB <- continuous_model(states, actions, params_subsidy_sustained, transition_fn, utility_fn)
solnB <- MDPtoolbox::mdp_value_iteration(modelB$P, modelB$U, discount)
start <- sim(solnB, Tmax=10, x0 = init)  
x10 <- start %>% filter(time == 10) %>% pull(state)
## Go another 10 years with decision rule under no subsidy
rest <- sim(soln, Tmax = 10, x0 = x10) %>% filter(time!=1) %>% mutate(time = time+10)
simB <- bind_rows(start, rest)

#write_csv(simA, "../data/simA.csv.gz")
#write_csv(simB, "../data/simB.csv.gz")
```

```{r fig_subsidy}
ggarrange(
     sim_plot(simA, panelA_title = ggtitle("A. Abrupt subsidy"), panelB_title = ggtitle(""), lab_lo_peak = TRUE, lab_hi_peak = TRUE, dnmarmod = -3.5), 
     sim_plot(simB, panelA_title = ggtitle("B. Sustained subsidy"), panelB_title = ggtitle(""), lab_lo_peak = TRUE, lab_hi_peak = TRUE, upmarmod = -3.5), 
     align = "h", nrow = 2, ncol = 1
     )
ggsave("figs/fig_subsidy.pdf", device = cairo_pdf, height = 6, width = 7)

print("abrupt: ")
p_up_dn(simA)
print("sustained: ")
p_up_dn(simB)
```

## System shocks (to-do)

```{r}

```



